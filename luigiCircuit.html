<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Luigi's Circuit</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="utils/earcut.min.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // better have some global variables to have them always available
        var car, item;
        var itemBoxPos = [], itemBoxes = [];
        var groundMat, streetMat, bleachersMat;

        const createScene = () => {
            
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            // building the ground as the base of our environment
            groundMat = new BABYLON.StandardMaterial("groundMat");
            groundMat.diffuseTexture = new BABYLON.Texture("textures/t_kusa_070712c.png");
            
            const ground = BABYLON.MeshBuilder.CreateDisc("ground", {radius: 650}, scene);
            ground.rotation.x = Math.PI / 2;
            ground.position.x = 325;
            ground.position.y = 0.49;
            ground.position.z = -60;
            ground.material = groundMat;

            // building the environment around the street
            
            bleacherMat = new BABYLON.StandardMaterial("bleacherMat");
            bleacherMat.diffuseTexture = new BABYLON.Texture("textures/lc_kakyutest.1.png");
            bleacherMat.diffuseTexture.hasAlpha = true;
            
            const bleacher = BABYLON.MeshBuilder.CreateBox("bleacher", {width:6, height:6, depth:0.1});
            bleacher.rotation.y = Math.PI/180 *70;
            bleacher.position.x = 15;
            bleacher.position.z = 18;
            bleacher.position.y = 2.7;
            bleacher.material = bleacherMat;
            for (i=1; i<3; i++){
                other_bleacher = bleacher.clone();
                other_bleacher.position.z = 18+12*i;
            }
            for (i=0; i<3; i++){
                other_bleacher = bleacher.clone();
                other_bleacher.position.x = -15;
                other_bleacher.position.z = 18+12*i;
                other_bleacher.rotation.y = Math.PI/180 *290;
            }

            // building the street
            streetMat = new BABYLON.StandardMaterial("streetMat");
            streetMat.diffuseTexture = new BABYLON.Texture("textures/mainROAD_all_mip_with_border.png");
            streetMat.diffuseTexture.hasAlpha = true;
            
            const street = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:60, depth:1});
            street.rotation.x = Math.PI / 2;
            street.material = streetMat;
            var pos_z = 60
            var pos_x = 10;
            for (i=0; i<6; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                pos_z += 60;
            }
            
            // first curve: we divide it in 4 pieces with an incremental orientation
            const curve = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:40, depth:1});
            curve.rotation.x = Math.PI / 2;
            curve.rotation.y = Math.PI / 9;
            curve.position.z = pos_z-17;
            curve.position.x = pos_x-4;
            pos_z += 14;
            pos_x += 13;
            angle = 2*Math.PI / 9;
            curve.material = streetMat;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                pos_z += 18;
                pos_x += 28;
                angle += Math.PI / 6;   
            }

            // second 'rettilineo' of other pieces of street
            pos_z -= 12;
            pos_x += 18;
            for (i=0; i<8; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x += 60;
            }

            // second curve: specular of the first one
            other_curve = curve.clone();
            other_curve.rotation.z += Math.PI / 2;
            other_curve.position.z = pos_z-7;
            other_curve.position.x = pos_x-15;
            pos_z -= 25;
            pos_x += 18;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z += Math.PI / 2;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                pos_z -= 28;
                pos_x += 20;
                angle += Math.PI / 6;   
            }

            // other straight line (greater than the previous one)
            pos_z -= 15;
            pos_x -= 15;
            for (i=0; i<14; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z -= 60;
            }

            // third curve
            other_curve = curve.clone();
            other_curve.rotation.z += Math.PI;
            other_curve.position.z = pos_z+14;
            other_curve.position.x = pos_x-4;
            pos_z -= 17;
            pos_x -= 25;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z += Math.PI;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                pos_z -= 23;
                pos_x -= 30;
                angle += Math.PI / 6;   
            }

            // third straight line
            pos_z += 15;
            pos_x -= 15;
            for (i=0; i<8; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x -= 60;
            }

            // forth and last curve
            other_curve = curve.clone();
            other_curve.rotation.z -= Math.PI/2;
            other_curve.position.z = pos_z+6;
            other_curve.position.x = pos_x+15;
            pos_z += 23;
            pos_x -= 15;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z -= Math.PI/2;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                pos_z += 27;//40 * Math.cos(angle) - (10*(i+1)) * Math.cos(angle);
                pos_x -= 20;
                //if (i == 0) pos_x += 40 * Math.sin(angle) + 10 * Math.sin(angle);
                //else pos_x += 40 * Math.sin(angle);
                angle += Math.PI / 6;   
            }

            // forth and last straight line
            pos_z += 15;
            pos_x += 15;
            for (i=0; i<6; i++){
                other_street = street.clone();
                other_street.rotation.y = Math.PI;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z += 60;
            }
            // add a last piece to nicely end the circuit
            other_street = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:74, depth:1});
            other_street.rotation.x = Math.PI / 2;
            other_street.material = streetMat;
            other_street.position.z = pos_z+7;
            other_street.position.x = pos_x;

            BABYLON.SceneLoader.ImportMeshAsync("", "models/", "Buggy.gltf", scene).then((result) => {
                car = result.meshes[0];
                car.scaling = new BABYLON.Vector3(0.02, 0.02, -0.02);
                car.position.x = -5;
                car.position.y = 0.7;
                car.rotationQuaternion = null;
                car.rotation.y = Math.PI;
                // the camera will follow the car with this
                camera.lockedTarget = car;
            });

            createItemBoxLine(scene, [-7, 1, 80]);
            

            // adding sounds
            const soundStart = new BABYLON.Sound("soundStart", "sounds/mk64_racestart.wav", scene, function(){
                soundStart.play();
            });

            // once the start sound is over we proceed with the countdown
            soundStart.onended = function(){

                // countdown for the race to start
                var countTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                var i = 3; // seconds
                var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                textBlock.color = "orange";
                textBlock.fontSize = 150;
                textBlock.fontFamily = "impact";
                
                countTexture.addControl(textBlock);
                var handle = window.setInterval(() => {
                    i--;
                    textBlock.text = new String(i)

                    if (i === 0) {
                        textBlock.text = "GO!"
                    }

                    if (i == -1){
                        window.clearInterval(handle);

                        textBlock.dispose();
                        countTexture.dispose();
                    }
                }, 890);
                
                const countSound = new BABYLON.Sound("countSound", "sounds/mk64_countdown.wav", scene, function(){
                    countSound.play();
                });
                
                countSound.onended = function(){
                    startRace(car);
                }
            };
            return scene;
        };

        // this fn creates a set of four aligned item boxes
        function createItemBoxLine(scene, starting_pos){
            BABYLON.SceneLoader.ImportMeshAsync("", "models/mario_kart_item_box/", "scene.gltf", scene).then((result) => {
                itemBox = result.meshes[0];
                itemBox.scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
                itemBox.position.z = starting_pos[2];
                itemBox.position.y = starting_pos[1];
                itemBox.position.x = starting_pos[0];
                itemBox.rotationQuaternion = null;  

                itemBoxPos.push([itemBox.position.x, itemBox.position.y, itemBox.position.z]);
                itemBoxes.push(itemBox);

                otherBox1 = itemBox.clone();
                otherBox2 = itemBox.clone();
                otherBox3 = itemBox.clone();

                otherBox1.position.x = itemBox.position.x + 4.5;
                otherBox2.position.x = itemBox.position.x + 9;
                otherBox3.position.x = itemBox.position.x + 13.5;
                
                itemBoxPos.push([otherBox1.position.x, otherBox1.position.y, otherBox1.position.z]);
                itemBoxPos.push([otherBox2.position.x, otherBox2.position.y, otherBox2.position.z]);
                itemBoxPos.push([otherBox3.position.x, otherBox3.position.y, otherBox3.position.z]);

                itemBoxes.push(otherBox1);
                itemBoxes.push(otherBox2);
                itemBoxes.push(otherBox3);
            });
        }

        // before use/throw the object we have it 'attached' to the car
        function createItem(name){
            if (name == 'banana'){
                item_name = 'banana';
                BABYLON.SceneLoader.ImportMeshAsync("", "models/banana_peel_mario_kart/", "scene.gltf", scene).then((result) => {
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.002, 0.002, 0.002);
                    item.position.y = 2.9;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                });
            }
            else if (name == 'red_shell'){
                item_name = 'red_shell';
                BABYLON.SceneLoader.ImportMeshAsync("", "models/red_shell/", "scene.gltf", scene).then((result) => {
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.15, 0.15, 0.15);
                    item.position.y = 2.9;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                });
            }
        }

        // if the car is out of the street I will have more friction
        function setImpedance(car) {
            impedance = 0.0;
            
            if ((car.position.z > -540 && car.position.z < 471 && car.position.x > -13 && car.position.x < 634)&&
                 !(car.position.z > -513 && car.position.z < 444 && car.position.x > 13.5 && car.position.x < 607))
                impedance = 0.0;
            else
                impedance = 0.25;

            return impedance;
        }

        function updateInfo(lap, position) {
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            let x = new BABYLON.GUI.TextBlock('TextBlock', '120'); 
            x.fontSize = 60;
            x.fontFamily = "impact";
            x.color = "yellow";
            var rect1 = new BABYLON.GUI.Rectangle();
            rect1.width = 0.25;
            rect1.horizontalAlignment = 1;
            rect1.verticalAlignment = 0;
            rect1.height = "150px";
            rect1.cornerRadius = 10;
            rect1.color = "black";
            rect1.thickness = 4;
            rect1.background = "grey";
            advancedTexture.addControl(rect1);
            rect1.addControl(x);

            x.text = 'Lap ' + String(lap) + '/3' + '\n Position: ' + String(position);
        }

        var lap = 1;
        var position = 1;

        function startRace(car) {
            updateInfo(lap, position);
            angle = car.rotation.y - Math.PI;
            // let's start the soundtrack of the Luigi's Circuit
            const luigiSound = new BABYLON.Sound("luigiSound", "sounds/mk64_luigicircuit.mp3", scene, null, {
                loop: true,
                autoplay: true 
            });

            var impedance = 0.0;
            // velocity increment when shell is thrown
            var throwed = 0;
            // You must arrive to half lap to increase lap when you arrive to the finish line
            // To ensure that the user actually follows the track
            var half_lap = false;
            scene.registerBeforeRender(function () {
                for (i=0; i<itemBoxPos.length; i++){
                    if(car.position.x < itemBoxPos[i][0]+0.8 && car.position.x > itemBoxPos[i][0]-0.8 && car.position.z < itemBoxPos[i][2]+0.8 && car.position.z > itemBoxPos[i][2]-0.8){
                        if(item)
                            item.position.y = 0.95;
                        if(Math.random()>0.5){
                            throwed = 0;
                            createItem('red_shell');
                        }
                        else{
                            throwed = 0;
                            createItem('banana');
                        }
                        itemBoxes[i].dispose();
                        itemBoxes.splice(i, 1);
                        itemBoxPos.splice(i, 1);
                        break;
                    }
                }
                impedance = setImpedance(car);
                if(lap <= 3){
                    car.position.z += (0.4 - impedance) * Math.cos(angle);
                    car.position.x += (0.4 - impedance) * Math.sin(angle);
                    if(item){
                        if(throwed == 0){
                            item.position.z += (0.4 + throwed - impedance) * Math.cos(angle);
                            item.position.x += (0.4 + throwed - impedance) * Math.sin(angle);
                            // saved to throw shell in the right direction
                            last_angle = angle;
                        }
                        else{
                            item.position.z += (0.4 + throwed - impedance)* Math.cos(last_angle);
                            item.position.x += (0.4 + throwed - impedance)* Math.sin(last_angle);
                        }
                    }
                    angle = car.rotation.y - Math.PI;
                    
                    if (car.position.z <37 && car.position.z >33 && car.position.x <640 && car.position.x >600)
                        half_lap = true;
                    if(half_lap && car.position.x <14 && car.position.x >-14 && car.position.z <3 && car.position.z >0){
                        if(lap <=2){
                            var lapTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            lapTexture.addControl(textBlock);
                            textBlock.text = "LAP " + String(lap) + " FINISHED!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                lapTexture.dispose();
                            }, 1000);
                            updateInfo(lap+1, position);
                        }
                        lap += 1;
                        half_lap = false;
                    }
                }
                else{
                    var finishTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                    textBlock.color = "orange";
                    textBlock.fontSize = 200;
                    textBlock.fontFamily = "impact";
                    
                    finishTexture.addControl(textBlock);
                    textBlock.text = "FINISH!";
                    var handle = window.setInterval(() => {
                        window.clearInterval(handle);
                        textBlock.dispose();
                        finishTexture.dispose();
                    }, 1000);
                }
            });

            scene.onKeyboardObservable.add((kbInfo) => {
                switch (kbInfo.type) {
                    case BABYLON.KeyboardEventTypes.KEYDOWN:
                        switch (kbInfo.event.key) {
                            case "a":
                            case "A":
                                car.rotation.y -= Math.PI / 12;
                            break
                            case "d":
                            case "D":
                                car.rotation.y += Math.PI / 12;
                            break
                            case "w":
                            case "W":
                                car.position.z += 1 * Math.cos(angle);
                                car.position.x += 1 * Math.sin(angle);
                                if(item && throwed == 0){
                                    item.position.z += 1 * Math.cos(angle);
                                    item.position.x += 1 * Math.sin(angle);
                                }
                            break
                            case "s":
                            case "S":
                                car.position.z -= 0.5 * Math.cos(angle);
                                car.position.x -= 0.5 * Math.sin(angle);
                                if(item && throwed == 0){
                                    item.position.z -= 0.5 * Math.cos(angle);
                                    item.position.x -= 0.5 * Math.sin(angle);
                                }
                            break
                            case "e":
                            case "E":
                                if(this.item_name == 'banana'){
                                    item.position.y = 0.95;
                                    item = null;
                                }
                                else if (this.item_name == 'red_shell'){
                                    item.position.y = 0.95;
                                    throwed = 0.6;
                                }
                            break
                        }
                    break;
                }
            });
        }

        const scene = createScene(); //Call the createScene function
        
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
